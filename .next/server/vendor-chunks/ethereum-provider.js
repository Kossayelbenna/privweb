"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethereum-provider";
exports.ids = ["vendor-chunks/ethereum-provider"];
exports.modules = {

/***/ "(ssr)/./node_modules/ethereum-provider/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/ethereum-provider/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst events_1 = __importDefault(__webpack_require__(/*! events */ \"events\"));\nconst payload_1 = __webpack_require__(/*! ./payload */ \"(ssr)/./node_modules/ethereum-provider/dist/payload.js\");\nclass Provider extends events_1.default {\n    constructor(connection) {\n        super();\n        this.promises = {};\n        this.attemptedSubscriptions = new Set();\n        this.subscriptions = [];\n        this.checkConnectionRunning = false;\n        this.nextId = 1;\n        this.connected = false;\n        this.accounts = [];\n        this.selectedAddress = undefined;\n        this.coinbase = undefined;\n        this.enable = this.enable.bind(this);\n        this.doSend = this.doSend.bind(this);\n        this.send = this.send.bind(this);\n        this.sendBatch = this.sendBatch.bind(this);\n        this.subscribe = this.subscribe.bind(this);\n        this.unsubscribe = this.unsubscribe.bind(this);\n        this.resumeSubscriptions = this.resumeSubscriptions.bind(this);\n        this.sendAsync = this.sendAsync.bind(this);\n        this.sendAsyncBatch = this.sendAsyncBatch.bind(this);\n        this.isConnected = this.isConnected.bind(this);\n        this.close = this.close.bind(this);\n        this.request = this.request.bind(this);\n        this.connection = connection;\n        this.on('connect', this.resumeSubscriptions);\n        this.connection.on('connect', () => this.checkConnection(1000));\n        this.connection.on('close', () => {\n            this.connected = false;\n            this.attemptedSubscriptions.clear();\n            this.emit('close');\n            this.emit('disconnect');\n        });\n        this.connection.on('payload', payload => {\n            const { id, method, error, result } = payload;\n            if (typeof id !== 'undefined') {\n                if (this.promises[id]) { // Fulfill promise\n                    const requestMethod = this.promises[id].method;\n                    if (requestMethod && ['eth_accounts', 'eth_requestAccounts'].includes(requestMethod)) {\n                        const accounts = result || [];\n                        this.accounts = accounts;\n                        this.selectedAddress = accounts[0];\n                        this.coinbase = accounts[0];\n                    }\n                    payload.error ? this.promises[id].reject(error) : this.promises[id].resolve(result);\n                    delete this.promises[id];\n                }\n            }\n            else if (method && method.indexOf('_subscription') > -1) { // Emit subscription result\n                // Events: connect, disconnect, chainChanged, chainsChanged, accountsChanged, assetsChanged, message\n                this.emit(payload.params.subscription, payload.params.result);\n                this.emit(method, payload.params); // Older EIP-1193\n                this.emit('message', {\n                    type: payload.method,\n                    data: {\n                        subscription: payload.params.subscription,\n                        result: payload.params.result\n                    }\n                });\n                this.emit('data', payload); // Backwards Compatibility\n            }\n        });\n        this.on('newListener', event => {\n            if (Object.keys(this.eventHandlers).includes(event)) {\n                if (!this.attemptedSubscription(event) && this.connected) {\n                    this.startSubscription(event);\n                    if (event === 'networkChanged') {\n                        console.warn('The networkChanged event is being deprecated, use chainChanged instead');\n                    }\n                }\n            }\n        });\n        this.eventHandlers = {\n            networkChanged: netId => {\n                this.networkVersion = (typeof netId === 'string') ? parseInt(netId) : netId;\n                this.emit('networkChanged', this.networkVersion);\n            },\n            chainChanged: chainId => {\n                this.providerChainId = chainId;\n                if (!this.manualChainId) {\n                    this.emit('chainChanged', chainId);\n                }\n            },\n            chainsChanged: chains => {\n                this.emit('chainsChanged', chains);\n            },\n            accountsChanged: (accounts) => {\n                this.selectedAddress = accounts[0];\n                this.emit('accountsChanged', accounts);\n            },\n            assetsChanged: assets => {\n                this.emit('assetsChanged', assets);\n            }\n        };\n    }\n    get chainId() {\n        return this.manualChainId || this.providerChainId;\n    }\n    async checkConnection(retryTimeout = 4000) {\n        if (this.checkConnectionRunning || this.connected)\n            return;\n        clearTimeout(this.checkConnectionTimer);\n        this.checkConnectionTimer = undefined;\n        this.checkConnectionRunning = true;\n        try {\n            this.networkVersion = await this.doSend('net_version', [], undefined, false);\n            this.providerChainId = await this.doSend('eth_chainId', [], undefined, false);\n            this.connected = true;\n        }\n        catch (e) {\n            this.checkConnectionTimer = setTimeout(() => this.checkConnection(), retryTimeout);\n            this.connected = false;\n        }\n        finally {\n            this.checkConnectionRunning = false;\n            if (this.connected) {\n                this.emit('connect', { chainId: this.providerChainId });\n            }\n        }\n    }\n    attemptedSubscription(event) {\n        return this.attemptedSubscriptions.has(event);\n    }\n    setSubscriptionAttempted(event) {\n        this.attemptedSubscriptions.add(event);\n    }\n    async startSubscription(event) {\n        console.debug(`starting subscription for ${event} events`);\n        this.setSubscriptionAttempted(event);\n        try {\n            const eventId = await (this.subscribe('eth_subscribe', event));\n            this.on(eventId, this.eventHandlers[event]);\n        }\n        catch (e) {\n            console.warn(`Unable to subscribe to ${event}`, e);\n        }\n    }\n    resumeSubscriptions() {\n        Object.keys(this.eventHandlers).forEach(event => {\n            if (this.listenerCount(event) && !this.attemptedSubscription(event))\n                this.startSubscription(event);\n        });\n    }\n    async enable() {\n        const accounts = await this.doSend('eth_accounts');\n        if (accounts.length > 0) {\n            this.accounts = accounts;\n            this.selectedAddress = accounts[0];\n            this.coinbase = accounts[0];\n            this.emit('enable');\n            return accounts;\n        }\n        else {\n            const err = new Error('User Denied Full Provider');\n            err.code = '4001';\n            throw err;\n        }\n    }\n    doSend(rawPayload, rawParams = [], targetChain = this.manualChainId, waitForConnection = true) {\n        const sendFn = (resolve, reject) => {\n            const method = (typeof rawPayload === 'object') ? rawPayload.method : rawPayload;\n            const params = (typeof rawPayload === 'object') ? rawPayload.params : rawParams;\n            const chainTarget = ((typeof rawPayload === 'object') && rawPayload.chainId) || targetChain;\n            if (!method) {\n                return reject(new Error('Method is not a valid string.'));\n            }\n            try {\n                const payload = (0, payload_1.create)(method, params, this.nextId++, chainTarget);\n                this.promises[payload.id] = {\n                    resolve: (result) => resolve(result),\n                    reject,\n                    method: payload.method\n                };\n                this.connection.send(payload);\n            }\n            catch (e) {\n                reject(e);\n            }\n        };\n        if (this.connected || !waitForConnection) {\n            return new Promise(sendFn);\n        }\n        return new Promise((resolve, reject) => {\n            const resolveSend = () => {\n                clearTimeout(disconnectTimer);\n                return resolve(new Promise(sendFn));\n            };\n            const disconnectTimer = setTimeout(() => {\n                this.off('connect', resolveSend);\n                reject(new Error('Not connected'));\n            }, 5000);\n            this.once('connect', resolveSend);\n        });\n    }\n    async send(methodOrPayload, callbackOrArgs) {\n        if (typeof methodOrPayload === 'string' &&\n            (!callbackOrArgs || Array.isArray(callbackOrArgs))) {\n            const params = callbackOrArgs;\n            return this.doSend(methodOrPayload, params);\n        }\n        if (methodOrPayload &&\n            typeof methodOrPayload === 'object' &&\n            typeof callbackOrArgs === 'function') {\n            // a callback was passed to send(), forward everything to sendAsync()\n            const cb = callbackOrArgs;\n            return this.sendAsync(methodOrPayload, cb);\n        }\n        return this.request(methodOrPayload);\n    }\n    sendBatch(requests) {\n        return Promise.all(requests.map(payload => {\n            return this.doSend(payload.method, payload.params);\n        }));\n    }\n    async subscribe(type, method, params = []) {\n        const id = await this.doSend(type, [method, ...params]);\n        this.subscriptions.push(id);\n        return id;\n    }\n    async unsubscribe(type, id) {\n        const success = await this.doSend(type, [id]);\n        if (success) {\n            this.subscriptions = this.subscriptions.filter(_id => _id !== id); // Remove subscription\n            this.removeAllListeners(id); // Remove listeners\n            return success;\n        }\n    }\n    async sendAsync(rawPayload, cb) {\n        if (!cb || typeof cb !== 'function')\n            return new Error('Invalid or undefined callback provided to sendAsync');\n        if (!rawPayload)\n            return cb(new Error('Invalid Payload'));\n        // sendAsync can be called with an array for batch requests used by web3.js 0.x\n        // this is not part of EIP-1193's backwards compatibility but we still want to support it\n        if (Array.isArray(rawPayload)) {\n            const payloads = rawPayload.map(p => ({ ...p, jsonrpc: '2.0' }));\n            const callback = cb;\n            return this.sendAsyncBatch(payloads, callback);\n        }\n        else {\n            const payload = { ...rawPayload, jsonrpc: '2.0' };\n            const callback = cb;\n            try {\n                const result = await this.doSend(payload.method, payload.params);\n                callback(null, { id: payload.id, jsonrpc: payload.jsonrpc, result });\n            }\n            catch (e) {\n                callback(e);\n            }\n        }\n    }\n    async sendAsyncBatch(payloads, cb) {\n        try {\n            const results = await this.sendBatch(payloads);\n            const result = results.map((entry, index) => {\n                return { id: payloads[index].id, jsonrpc: payloads[index].jsonrpc, result: entry };\n            });\n            cb(null, result);\n        }\n        catch (e) {\n            cb(e);\n        }\n    }\n    isConnected() {\n        return this.connected;\n    }\n    close() {\n        if (this.connection && this.connection.close)\n            this.connection.close();\n        this.off('connect', this.resumeSubscriptions);\n        this.connected = false;\n        const error = new Error('Provider closed, subscription lost, please subscribe again.');\n        this.subscriptions.forEach(id => this.emit(id, error)); // Send Error objects to any open subscriptions\n        this.subscriptions = []; // Clear subscriptions\n        this.manualChainId = undefined;\n        this.providerChainId = undefined;\n        this.networkVersion = undefined;\n        this.selectedAddress = undefined;\n        this.coinbase = undefined;\n    }\n    async request(payload) {\n        return this.doSend(payload.method, payload.params, payload.chainId);\n    }\n    setChain(chainId) {\n        if (typeof chainId === 'number')\n            chainId = '0x' + chainId.toString(16);\n        const chainChanged = (chainId !== this.chainId);\n        this.manualChainId = chainId;\n        if (chainChanged) {\n            this.emit('chainChanged', this.chainId);\n        }\n    }\n}\nexports[\"default\"] = Provider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tcHJvdmlkZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlDQUFpQyxtQkFBTyxDQUFDLHNCQUFRO0FBQ2pELGtCQUFrQixtQkFBTyxDQUFDLHlFQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsNENBQTRDO0FBQzVDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsK0JBQStCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE1BQU07QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0UseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsc0JBQXNCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrREFBa0Q7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2NyeXB0by1jbGllbnQvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tcHJvdmlkZXIvZGlzdC9pbmRleC5qcz9mOWUzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZXZlbnRzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImV2ZW50c1wiKSk7XG5jb25zdCBwYXlsb2FkXzEgPSByZXF1aXJlKFwiLi9wYXlsb2FkXCIpO1xuY2xhc3MgUHJvdmlkZXIgZXh0ZW5kcyBldmVudHNfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucHJvbWlzZXMgPSB7fTtcbiAgICAgICAgdGhpcy5hdHRlbXB0ZWRTdWJzY3JpcHRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5jaGVja0Nvbm5lY3Rpb25SdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmV4dElkID0gMTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hY2NvdW50cyA9IFtdO1xuICAgICAgICB0aGlzLnNlbGVjdGVkQWRkcmVzcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jb2luYmFzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5lbmFibGUgPSB0aGlzLmVuYWJsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRvU2VuZCA9IHRoaXMuZG9TZW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2VuZCA9IHRoaXMuc2VuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNlbmRCYXRjaCA9IHRoaXMuc2VuZEJhdGNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlID0gdGhpcy5zdWJzY3JpYmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSA9IHRoaXMudW5zdWJzY3JpYmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZXN1bWVTdWJzY3JpcHRpb25zID0gdGhpcy5yZXN1bWVTdWJzY3JpcHRpb25zLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2VuZEFzeW5jID0gdGhpcy5zZW5kQXN5bmMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZW5kQXN5bmNCYXRjaCA9IHRoaXMuc2VuZEFzeW5jQmF0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IHRoaXMuaXNDb25uZWN0ZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jbG9zZSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIHRoaXMub24oJ2Nvbm5lY3QnLCB0aGlzLnJlc3VtZVN1YnNjcmlwdGlvbnMpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24ub24oJ2Nvbm5lY3QnLCAoKSA9PiB0aGlzLmNoZWNrQ29ubmVjdGlvbigxMDAwKSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hdHRlbXB0ZWRTdWJzY3JpcHRpb25zLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5vbigncGF5bG9hZCcsIHBheWxvYWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpZCwgbWV0aG9kLCBlcnJvciwgcmVzdWx0IH0gPSBwYXlsb2FkO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9taXNlc1tpZF0pIHsgLy8gRnVsZmlsbCBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RNZXRob2QgPSB0aGlzLnByb21pc2VzW2lkXS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0TWV0aG9kICYmIFsnZXRoX2FjY291bnRzJywgJ2V0aF9yZXF1ZXN0QWNjb3VudHMnXS5pbmNsdWRlcyhyZXF1ZXN0TWV0aG9kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSByZXN1bHQgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjY291bnRzID0gYWNjb3VudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkQWRkcmVzcyA9IGFjY291bnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2luYmFzZSA9IGFjY291bnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuZXJyb3IgPyB0aGlzLnByb21pc2VzW2lkXS5yZWplY3QoZXJyb3IpIDogdGhpcy5wcm9taXNlc1tpZF0ucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5wcm9taXNlc1tpZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWV0aG9kICYmIG1ldGhvZC5pbmRleE9mKCdfc3Vic2NyaXB0aW9uJykgPiAtMSkgeyAvLyBFbWl0IHN1YnNjcmlwdGlvbiByZXN1bHRcbiAgICAgICAgICAgICAgICAvLyBFdmVudHM6IGNvbm5lY3QsIGRpc2Nvbm5lY3QsIGNoYWluQ2hhbmdlZCwgY2hhaW5zQ2hhbmdlZCwgYWNjb3VudHNDaGFuZ2VkLCBhc3NldHNDaGFuZ2VkLCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KHBheWxvYWQucGFyYW1zLnN1YnNjcmlwdGlvbiwgcGF5bG9hZC5wYXJhbXMucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQobWV0aG9kLCBwYXlsb2FkLnBhcmFtcyk7IC8vIE9sZGVyIEVJUC0xMTkzXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBwYXlsb2FkLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uOiBwYXlsb2FkLnBhcmFtcy5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHBheWxvYWQucGFyYW1zLnJlc3VsdFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgcGF5bG9hZCk7IC8vIEJhY2t3YXJkcyBDb21wYXRpYmlsaXR5XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKCduZXdMaXN0ZW5lcicsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmV2ZW50SGFuZGxlcnMpLmluY2x1ZGVzKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hdHRlbXB0ZWRTdWJzY3JpcHRpb24oZXZlbnQpICYmIHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTdWJzY3JpcHRpb24oZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQgPT09ICduZXR3b3JrQ2hhbmdlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhlIG5ldHdvcmtDaGFuZ2VkIGV2ZW50IGlzIGJlaW5nIGRlcHJlY2F0ZWQsIHVzZSBjaGFpbkNoYW5nZWQgaW5zdGVhZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzID0ge1xuICAgICAgICAgICAgbmV0d29ya0NoYW5nZWQ6IG5ldElkID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm5ldHdvcmtWZXJzaW9uID0gKHR5cGVvZiBuZXRJZCA9PT0gJ3N0cmluZycpID8gcGFyc2VJbnQobmV0SWQpIDogbmV0SWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCduZXR3b3JrQ2hhbmdlZCcsIHRoaXMubmV0d29ya1ZlcnNpb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoYWluQ2hhbmdlZDogY2hhaW5JZCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlckNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYW51YWxDaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY2hhaW5DaGFuZ2VkJywgY2hhaW5JZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoYWluc0NoYW5nZWQ6IGNoYWlucyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjaGFpbnNDaGFuZ2VkJywgY2hhaW5zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhY2NvdW50c0NoYW5nZWQ6IChhY2NvdW50cykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRBZGRyZXNzID0gYWNjb3VudHNbMF07XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdhY2NvdW50c0NoYW5nZWQnLCBhY2NvdW50cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXNzZXRzQ2hhbmdlZDogYXNzZXRzID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Fzc2V0c0NoYW5nZWQnLCBhc3NldHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgY2hhaW5JZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFudWFsQ2hhaW5JZCB8fCB0aGlzLnByb3ZpZGVyQ2hhaW5JZDtcbiAgICB9XG4gICAgYXN5bmMgY2hlY2tDb25uZWN0aW9uKHJldHJ5VGltZW91dCA9IDQwMDApIHtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tDb25uZWN0aW9uUnVubmluZyB8fCB0aGlzLmNvbm5lY3RlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY2hlY2tDb25uZWN0aW9uVGltZXIpO1xuICAgICAgICB0aGlzLmNoZWNrQ29ubmVjdGlvblRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNoZWNrQ29ubmVjdGlvblJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5uZXR3b3JrVmVyc2lvbiA9IGF3YWl0IHRoaXMuZG9TZW5kKCduZXRfdmVyc2lvbicsIFtdLCB1bmRlZmluZWQsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJDaGFpbklkID0gYXdhaXQgdGhpcy5kb1NlbmQoJ2V0aF9jaGFpbklkJywgW10sIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrQ29ubmVjdGlvblRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmNoZWNrQ29ubmVjdGlvbigpLCByZXRyeVRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tDb25uZWN0aW9uUnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0JywgeyBjaGFpbklkOiB0aGlzLnByb3ZpZGVyQ2hhaW5JZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhdHRlbXB0ZWRTdWJzY3JpcHRpb24oZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0ZW1wdGVkU3Vic2NyaXB0aW9ucy5oYXMoZXZlbnQpO1xuICAgIH1cbiAgICBzZXRTdWJzY3JpcHRpb25BdHRlbXB0ZWQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5hdHRlbXB0ZWRTdWJzY3JpcHRpb25zLmFkZChldmVudCk7XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0U3Vic2NyaXB0aW9uKGV2ZW50KSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoYHN0YXJ0aW5nIHN1YnNjcmlwdGlvbiBmb3IgJHtldmVudH0gZXZlbnRzYCk7XG4gICAgICAgIHRoaXMuc2V0U3Vic2NyaXB0aW9uQXR0ZW1wdGVkKGV2ZW50KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50SWQgPSBhd2FpdCAodGhpcy5zdWJzY3JpYmUoJ2V0aF9zdWJzY3JpYmUnLCBldmVudCkpO1xuICAgICAgICAgICAgdGhpcy5vbihldmVudElkLCB0aGlzLmV2ZW50SGFuZGxlcnNbZXZlbnRdKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmFibGUgdG8gc3Vic2NyaWJlIHRvICR7ZXZlbnR9YCwgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdW1lU3Vic2NyaXB0aW9ucygpIHtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5ldmVudEhhbmRsZXJzKS5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoZXZlbnQpICYmICF0aGlzLmF0dGVtcHRlZFN1YnNjcmlwdGlvbihldmVudCkpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFN1YnNjcmlwdGlvbihldmVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBlbmFibGUoKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5kb1NlbmQoJ2V0aF9hY2NvdW50cycpO1xuICAgICAgICBpZiAoYWNjb3VudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5hY2NvdW50cyA9IGFjY291bnRzO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEFkZHJlc3MgPSBhY2NvdW50c1swXTtcbiAgICAgICAgICAgIHRoaXMuY29pbmJhc2UgPSBhY2NvdW50c1swXTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZW5hYmxlJyk7XG4gICAgICAgICAgICByZXR1cm4gYWNjb3VudHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ1VzZXIgRGVuaWVkIEZ1bGwgUHJvdmlkZXInKTtcbiAgICAgICAgICAgIGVyci5jb2RlID0gJzQwMDEnO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvU2VuZChyYXdQYXlsb2FkLCByYXdQYXJhbXMgPSBbXSwgdGFyZ2V0Q2hhaW4gPSB0aGlzLm1hbnVhbENoYWluSWQsIHdhaXRGb3JDb25uZWN0aW9uID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBzZW5kRm4gPSAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXRob2QgPSAodHlwZW9mIHJhd1BheWxvYWQgPT09ICdvYmplY3QnKSA/IHJhd1BheWxvYWQubWV0aG9kIDogcmF3UGF5bG9hZDtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9ICh0eXBlb2YgcmF3UGF5bG9hZCA9PT0gJ29iamVjdCcpID8gcmF3UGF5bG9hZC5wYXJhbXMgOiByYXdQYXJhbXM7XG4gICAgICAgICAgICBjb25zdCBjaGFpblRhcmdldCA9ICgodHlwZW9mIHJhd1BheWxvYWQgPT09ICdvYmplY3QnKSAmJiByYXdQYXlsb2FkLmNoYWluSWQpIHx8IHRhcmdldENoYWluO1xuICAgICAgICAgICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTWV0aG9kIGlzIG5vdCBhIHZhbGlkIHN0cmluZy4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSAoMCwgcGF5bG9hZF8xLmNyZWF0ZSkobWV0aG9kLCBwYXJhbXMsIHRoaXMubmV4dElkKyssIGNoYWluVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb21pc2VzW3BheWxvYWQuaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlOiAocmVzdWx0KSA9PiByZXNvbHZlKHJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBwYXlsb2FkLm1ldGhvZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLnNlbmQocGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkIHx8ICF3YWl0Rm9yQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHNlbmRGbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVTZW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChkaXNjb25uZWN0VGltZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG5ldyBQcm9taXNlKHNlbmRGbikpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGRpc2Nvbm5lY3RUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdjb25uZWN0JywgcmVzb2x2ZVNlbmQpO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ05vdCBjb25uZWN0ZWQnKSk7XG4gICAgICAgICAgICB9LCA1MDAwKTtcbiAgICAgICAgICAgIHRoaXMub25jZSgnY29ubmVjdCcsIHJlc29sdmVTZW5kKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmQobWV0aG9kT3JQYXlsb2FkLCBjYWxsYmFja09yQXJncykge1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZE9yUGF5bG9hZCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICghY2FsbGJhY2tPckFyZ3MgfHwgQXJyYXkuaXNBcnJheShjYWxsYmFja09yQXJncykpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBjYWxsYmFja09yQXJncztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvU2VuZChtZXRob2RPclBheWxvYWQsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZE9yUGF5bG9hZCAmJlxuICAgICAgICAgICAgdHlwZW9mIG1ldGhvZE9yUGF5bG9hZCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYWxsYmFja09yQXJncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gYSBjYWxsYmFjayB3YXMgcGFzc2VkIHRvIHNlbmQoKSwgZm9yd2FyZCBldmVyeXRoaW5nIHRvIHNlbmRBc3luYygpXG4gICAgICAgICAgICBjb25zdCBjYiA9IGNhbGxiYWNrT3JBcmdzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZEFzeW5jKG1ldGhvZE9yUGF5bG9hZCwgY2IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWV0aG9kT3JQYXlsb2FkKTtcbiAgICB9XG4gICAgc2VuZEJhdGNoKHJlcXVlc3RzKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChyZXF1ZXN0cy5tYXAocGF5bG9hZCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb1NlbmQocGF5bG9hZC5tZXRob2QsIHBheWxvYWQucGFyYW1zKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBzdWJzY3JpYmUodHlwZSwgbWV0aG9kLCBwYXJhbXMgPSBbXSkge1xuICAgICAgICBjb25zdCBpZCA9IGF3YWl0IHRoaXMuZG9TZW5kKHR5cGUsIFttZXRob2QsIC4uLnBhcmFtc10pO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChpZCk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgYXN5bmMgdW5zdWJzY3JpYmUodHlwZSwgaWQpIHtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHRoaXMuZG9TZW5kKHR5cGUsIFtpZF0pO1xuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zLmZpbHRlcihfaWQgPT4gX2lkICE9PSBpZCk7IC8vIFJlbW92ZSBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGlkKTsgLy8gUmVtb3ZlIGxpc3RlbmVyc1xuICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2VuZEFzeW5jKHJhd1BheWxvYWQsIGNiKSB7XG4gICAgICAgIGlmICghY2IgfHwgdHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCBvciB1bmRlZmluZWQgY2FsbGJhY2sgcHJvdmlkZWQgdG8gc2VuZEFzeW5jJyk7XG4gICAgICAgIGlmICghcmF3UGF5bG9hZClcbiAgICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ0ludmFsaWQgUGF5bG9hZCcpKTtcbiAgICAgICAgLy8gc2VuZEFzeW5jIGNhbiBiZSBjYWxsZWQgd2l0aCBhbiBhcnJheSBmb3IgYmF0Y2ggcmVxdWVzdHMgdXNlZCBieSB3ZWIzLmpzIDAueFxuICAgICAgICAvLyB0aGlzIGlzIG5vdCBwYXJ0IG9mIEVJUC0xMTkzJ3MgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgYnV0IHdlIHN0aWxsIHdhbnQgdG8gc3VwcG9ydCBpdFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyYXdQYXlsb2FkKSkge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZHMgPSByYXdQYXlsb2FkLm1hcChwID0+ICh7IC4uLnAsIGpzb25ycGM6ICcyLjAnIH0pKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gY2I7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kQXN5bmNCYXRjaChwYXlsb2FkcywgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHsgLi4ucmF3UGF5bG9hZCwganNvbnJwYzogJzIuMCcgfTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gY2I7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZG9TZW5kKHBheWxvYWQubWV0aG9kLCBwYXlsb2FkLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeyBpZDogcGF5bG9hZC5pZCwganNvbnJwYzogcGF5bG9hZC5qc29ucnBjLCByZXN1bHQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNlbmRBc3luY0JhdGNoKHBheWxvYWRzLCBjYikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuc2VuZEJhdGNoKHBheWxvYWRzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHMubWFwKChlbnRyeSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBpZDogcGF5bG9hZHNbaW5kZXhdLmlkLCBqc29ucnBjOiBwYXlsb2Fkc1tpbmRleF0uanNvbnJwYywgcmVzdWx0OiBlbnRyeSB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYihudWxsLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjYihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGVkO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbiAmJiB0aGlzLmNvbm5lY3Rpb24uY2xvc2UpXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgdGhpcy5vZmYoJ2Nvbm5lY3QnLCB0aGlzLnJlc3VtZVN1YnNjcmlwdGlvbnMpO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignUHJvdmlkZXIgY2xvc2VkLCBzdWJzY3JpcHRpb24gbG9zdCwgcGxlYXNlIHN1YnNjcmliZSBhZ2Fpbi4nKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goaWQgPT4gdGhpcy5lbWl0KGlkLCBlcnJvcikpOyAvLyBTZW5kIEVycm9yIG9iamVjdHMgdG8gYW55IG9wZW4gc3Vic2NyaXB0aW9uc1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTsgLy8gQ2xlYXIgc3Vic2NyaXB0aW9uc1xuICAgICAgICB0aGlzLm1hbnVhbENoYWluSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucHJvdmlkZXJDaGFpbklkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm5ldHdvcmtWZXJzaW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNlbGVjdGVkQWRkcmVzcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jb2luYmFzZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYXN5bmMgcmVxdWVzdChwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvU2VuZChwYXlsb2FkLm1ldGhvZCwgcGF5bG9hZC5wYXJhbXMsIHBheWxvYWQuY2hhaW5JZCk7XG4gICAgfVxuICAgIHNldENoYWluKGNoYWluSWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGFpbklkID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIGNoYWluSWQgPSAnMHgnICsgY2hhaW5JZC50b1N0cmluZygxNik7XG4gICAgICAgIGNvbnN0IGNoYWluQ2hhbmdlZCA9IChjaGFpbklkICE9PSB0aGlzLmNoYWluSWQpO1xuICAgICAgICB0aGlzLm1hbnVhbENoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICBpZiAoY2hhaW5DaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2NoYWluQ2hhbmdlZCcsIHRoaXMuY2hhaW5JZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-provider/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-provider/dist/payload.js":
/*!********************************************************!*\
  !*** ./node_modules/ethereum-provider/dist/payload.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.create = void 0;\nfunction create(method, params = [], id, targetChain) {\n    const payload = {\n        id, method, params, jsonrpc: '2.0'\n    };\n    if (targetChain) {\n        payload.chainId = targetChain;\n    }\n    if (payload.method === 'eth_sendTransaction') {\n        const mismatchedChain = isChainMismatch(payload);\n        if (mismatchedChain) {\n            throw new Error(`Payload chainId (${mismatchedChain}) inconsistent with specified target chainId: ${targetChain}`);\n        }\n        return updatePayloadChain(payload);\n    }\n    return payload;\n}\nexports.create = create;\nfunction isChainMismatch(payload) {\n    if (payload.method !== 'eth_sendTransaction')\n        return false;\n    const tx = payload.params[0] || {};\n    const chainId = tx.chainId;\n    return ('chainId' in tx) && parseInt(chainId) !== parseInt(payload.chainId || chainId);\n}\nfunction updatePayloadChain(payload) {\n    const tx = payload.params[0] || {};\n    return { ...payload, params: [{ ...tx, chainId: tx.chainId || payload.chainId }, ...payload.params.slice(1)] };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tcHJvdmlkZXIvZGlzdC9wYXlsb2FkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnQkFBZ0IsZ0RBQWdELFlBQVk7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QiwrQ0FBK0M7QUFDbkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcnlwdG8tY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtLXByb3ZpZGVyL2Rpc3QvcGF5bG9hZC5qcz9mN2UxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGUgPSB2b2lkIDA7XG5mdW5jdGlvbiBjcmVhdGUobWV0aG9kLCBwYXJhbXMgPSBbXSwgaWQsIHRhcmdldENoYWluKSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgaWQsIG1ldGhvZCwgcGFyYW1zLCBqc29ucnBjOiAnMi4wJ1xuICAgIH07XG4gICAgaWYgKHRhcmdldENoYWluKSB7XG4gICAgICAgIHBheWxvYWQuY2hhaW5JZCA9IHRhcmdldENoYWluO1xuICAgIH1cbiAgICBpZiAocGF5bG9hZC5tZXRob2QgPT09ICdldGhfc2VuZFRyYW5zYWN0aW9uJykge1xuICAgICAgICBjb25zdCBtaXNtYXRjaGVkQ2hhaW4gPSBpc0NoYWluTWlzbWF0Y2gocGF5bG9hZCk7XG4gICAgICAgIGlmIChtaXNtYXRjaGVkQ2hhaW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGF5bG9hZCBjaGFpbklkICgke21pc21hdGNoZWRDaGFpbn0pIGluY29uc2lzdGVudCB3aXRoIHNwZWNpZmllZCB0YXJnZXQgY2hhaW5JZDogJHt0YXJnZXRDaGFpbn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBkYXRlUGF5bG9hZENoYWluKHBheWxvYWQpO1xuICAgIH1cbiAgICByZXR1cm4gcGF5bG9hZDtcbn1cbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZnVuY3Rpb24gaXNDaGFpbk1pc21hdGNoKHBheWxvYWQpIHtcbiAgICBpZiAocGF5bG9hZC5tZXRob2QgIT09ICdldGhfc2VuZFRyYW5zYWN0aW9uJylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHR4ID0gcGF5bG9hZC5wYXJhbXNbMF0gfHwge307XG4gICAgY29uc3QgY2hhaW5JZCA9IHR4LmNoYWluSWQ7XG4gICAgcmV0dXJuICgnY2hhaW5JZCcgaW4gdHgpICYmIHBhcnNlSW50KGNoYWluSWQpICE9PSBwYXJzZUludChwYXlsb2FkLmNoYWluSWQgfHwgY2hhaW5JZCk7XG59XG5mdW5jdGlvbiB1cGRhdGVQYXlsb2FkQ2hhaW4ocGF5bG9hZCkge1xuICAgIGNvbnN0IHR4ID0gcGF5bG9hZC5wYXJhbXNbMF0gfHwge307XG4gICAgcmV0dXJuIHsgLi4ucGF5bG9hZCwgcGFyYW1zOiBbeyAuLi50eCwgY2hhaW5JZDogdHguY2hhaW5JZCB8fCBwYXlsb2FkLmNoYWluSWQgfSwgLi4ucGF5bG9hZC5wYXJhbXMuc2xpY2UoMSldIH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-provider/dist/payload.js\n");

/***/ })

};
;